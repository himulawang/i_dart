/**
 * This script is generated by I Maker
 * DO NOT MODIFY!
 */


part of lib_test_server_store;

class RoomPKMariaDBStore extends IMariaDBStore {
  static const _key = 'r-pk';
  static const _table = 'PK';
  static const Map store = const {"type":"mariaDB","readWriteSeparate":false,"shardMethod":"NONE","master":"SingleDB","slave":"SingleDBSlave","abb":"r","table":"PK"};
  static const _modelName = 'RoomPK';

  static Future set(RoomPK pk) {
    if (pk is! RoomPK) throw new IStoreException(21036, [pk.runtimeType, _modelName]);
    if (!pk.isUpdated()) {
      new IStoreException(21506, [_modelName]);
      Completer completer = new Completer();
      completer.complete(pk);
      return completer.future;
    }

    num value = pk.get();
    if (value is! num) throw new IStoreException(21037, [_modelName]);

    ConnectionPool handler = new IMariaDBHandlerPool().getWriteHandler(store, _key);
    return handler.prepareExecute('INSERT INTO `${_table}` (`key`, `pk`) VALUES (?, ?) ON DUPLICATE KEY UPDATE `pk` = ?;', [_key, value, value])
    .then((Results results) {
      if (results.affectedRows == 0) throw new IStoreException(21038, [_modelName]);
      return pk..setUpdated(false);
    })
    .catchError(_handleErr);
  }

  static Future get() {
    RoomPK pk = new RoomPK();

    ConnectionPool handler = new IMariaDBHandlerPool().getReaderHandler(store, _key);

    return handler.prepareExecute('SELECT `pk` FROM `${_table}` WHERE `key` = ?', [_key])
    .then((Results results) => results.toList())
    .then((List list) {
      if (list.length == 0) return pk;
      return pk..set(list[0][0])..setUpdated(false);
    })
    .catchError(_handleErr);
  }

  static Future del(pk) {
    ConnectionPool handler = new IMariaDBHandlerPool().getWriteHandler(store, _key);

    return handler.prepareExecute('DELETE FROM `${_table}` WHERE `key` = ?', [_key])
    .then((Results results) {
      if (results.affectedRows == 0) new IStoreException(21507, [_modelName]);
      if (results.affectedRows == 1) return true;
      return false;
    })
    .catchError(_handleErr);
  }

  static void _handleErr(e) => throw e;
}
