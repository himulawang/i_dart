part of i_maker;

class IMaker {
  String _iPath;
  String _app;
  String _appPath;
  final String _DECLARATION = '''
/**
 * This script is generated by I Maker
 * DO NOT MODIFY!
 */
''';

  IMaker(Map deploy) {
    _iPath = deploy['iPath'];
    _app = deploy['app'];
    _appPath = deploy['appPath'];
  }

/**
 * Return a unrepeated abbreviation list
 *
 *     columns = ['id', 'name', 'gender', 'address', 'address1',
 *       'address2', 'familyName', 'founderName', 'fatherName'];
 * become
 *     abbs = ['i', 'n', 'g', 'a', 'a1', 'a2', 'fn', 'fn1']
 *
 * * Rule1: single lowercase word: id => i
 * * Rule2: multiple words: familyName => fn
 * * Rule3: multiple words and conflict with previous abbreviation: founderName => fn1, fatherName => fn2
 * * Rule4: words end with number: address1 => a1, address2 => a2
 */
  Map makeAbbs(List columns) {
    Map abbs = {};
    num i = 0;

    columns.forEach((String full) {
      String candidateAbb = makeAbb(full);
      while (abbs.containsValue(candidateAbb)) {
        candidateAbb = renameAbb(candidateAbb);
      }
      abbs[full] = candidateAbb;
    });

    return abbs;
  }

/**
 * make single word to abbreviation
 */
  String makeAbb(String full) {
    RegExp reg = new RegExp(r'[a-z]');
    return (full[0] + full.replaceAll(reg, '')).toLowerCase();
  }

/**
 * Regenerate abbreviation if conflict with previous.
 */
  String renameAbb(String abb) {
    RegExp reg = new RegExp(r'^([a-zA-Z0-9]+)(\d+)$');

    String newAbb;
    if (reg.hasMatch(abb)) {
      reg.allMatches(abb).forEach((matches) {
        newAbb = '${matches.group(1)}${(int.parse(matches.group(2)) + 1)}';
      });
    } else {
      newAbb = '${abb}1';
    }
    return newAbb;
  }

/**
 * Convert multiple words to underline words
 */
  String makeLowerUnderline(String full) {
    RegExp reg = new RegExp(r'([A-Z])([a-z0-9]+)');

    String lowerName;
    if (reg.hasMatch(full)) {
      int loop = 0;
      Iterable matchGroup = reg.allMatches(full);
      matchGroup.forEach((matches) {
        if (loop == 0) {
          lowerName = matches.group(0).toLowerCase();
        } else {
          lowerName += '_${matches.group(1).toLowerCase()}${matches.group(2)}';
        }

        ++loop;
      });
    } else {
      print('orm.dart wrong.');
    }

    return lowerName;
  }

/**
 * Uppercase first character of word
 */
  String makeUpperFirstLetter(String word) {
    if (word.length <= 1) return word.toUpperCase();
    return word[0].toUpperCase() + word.substring(1);
  }

/**
 * Copy file from srcPath/srcFileName to targetPath/targetFileName
 */
  void copyFile(String srcPath, String srcFileName, String targetPath, String targetFileName) {
    File file = new File('${srcPath}/${srcFileName}');
    file.readAsString().then((String content) {
      writeFile(targetFileName, targetPath, content, true);
    });
  }

/**
 * Copy file from srcPath/srcFileName to targetPath/targetFileName with header
 */
  void copyFileWithHeader(String srcPath, String srcFileName, String targetPath, String targetFileName, String header) {
    File file = new File('${srcPath}/${srcFileName}');
    file.readAsString().then((String content) {
      StringBuffer allContentSB = new StringBuffer(header)..write('\n\n')..write(content);
      writeFile(targetFileName, targetPath, allContentSB.toString(), true);
    });
  }

/**
 * Write content to file handler
 */
  void write(File file, String content) {
    IOSink sink = file.openWrite();
    sink.write(content);
    sink.close();
    print('Write ${file.path} Done.');
  }

/**
 * Write content to file
 */
  void writeFile(String name, String path, String content, [bool overwrite = true]) {
    String fullName = '${path}/${name}';
    File file = new File(fullName);

    if (overwrite) {
      write(file, content);
    } else {
      file.exists().then((found) {
        if (!found) {
          write(file, content);
        }
      });
      print('${file.path} exists, skip.');
    }
  }
}
