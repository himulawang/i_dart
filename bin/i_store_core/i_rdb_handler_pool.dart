/**
 * This script is generated by I Maker
 * DO NOT MODIFY!
 */

class IRedisHandlerPool {
  static bool _initialized = false;
  static IRedisHandlerPool _instance;

  static final Map dbs = <String, List<RedisClient>>{};
  static final Map nodesLength = <String, int>{};

  Future init(Map config) {
    // for configs
    List waitList = [];
    config.forEach((String groupName, List group) {
      // get groupName
      dbs[groupName] = new List(group.length);
      nodesLength[groupName] = group.length;

      // for nodes
      group.forEach((Map node) {
        String connectionString = _makeConnectionString(node);
        waitList.add(
            RedisClient
            .connect(connectionString)
            .then((RedisClient client) => dbs[groupName][node['no']] = client)
            .catchError(_handleErr)
        );
      });
    });
    return Future.wait(waitList).then((_) {
      _initialized = true;
      print('Redis connected.');
    });
  }

  factory IRedisHandlerPool() {
    if (_instance is IRedisHandlerPool) return _instance;
    _instance = new IRedisHandlerPool._internal();
    return _instance;
  }

  IRedisHandlerPool._internal();

  static String _makeConnectionString(Map node) {
    // check node config
    if (!node.containsKey('no')) throw new IStoreException(20001);
    if (!node.containsKey('host')) throw new IStoreException(20002);
    if (!node.containsKey('port')) throw new IStoreException(20003);
    if (!node.containsKey('pwd')) throw new IStoreException(20004);
    if (!node.containsKey('db')) throw new IStoreException(20005);

    StringBuffer connectionSB = new StringBuffer();

    if (node['pwd'] is String) {
      connectionSB.writeAll([node['pwd'], '@']);
    }

    if (node['host'] is! String) throw new IStoreException(20006);
    connectionSB.write(node['host']);

    connectionSB.write(':');
    if (node['port'] is int) {
      connectionSB.write(node['port'].toString());
    } else {
      connectionSB.write('6379');
    }

    if (node['db'] is String) {
      connectionSB.writeAll(['/', node['db']]);
    }

    return connectionSB.toString();
  }

  static void _handleErr(err) {
    throw err;
  }

  RedisClient getWriteHandler(model) {
    _checkInitialized();

    Map redisStore = model.getRedisStore();
    String groupType = 'master';
    String groupName = redisStore[groupType];

    int modValue = nodesLength[groupName];
    int shardIndex = _getShardIndex(redisStore['shardMethod'], model, modValue);

    return dbs[groupName][shardIndex];
  }

  RedisClient getReaderHandler(model) {
    _checkInitialized();

    Map redisStore = model.getRedisStore();
    String groupType = redisStore['readWriteSeparate'] ? 'slave' : 'master';
    String groupName = redisStore[groupType];

    int modValue = nodesLength[groupName];
    int shardIndex = _getShardIndex(redisStore['shardMethod'], model, modValue);

    return dbs[groupName][shardIndex];
  }

  void _checkInitialized() {
    if (!_initialized) throw new IStoreException(20033);
  }

  int _getShardIndex(String shardMethod, model, num modValue) {
    int shardIndex;
    switch (shardMethod) {
      case 'NONE':
        shardIndex = 0;
        break;
      case 'CRC32':
        shardIndex = CRC32.compute(model.getPK().toString()) % modValue;
        break;
      default:
        throw new IStoreException(20008);
    }
    return shardIndex;
  }
}

